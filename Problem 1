// Explanation -  one binary search to find the first occurance and second binary search to find the last occurence of the target. If the mid is equal to target , check if its the fisrt occurence by comparing with thr previous element, else follow normal binary search rule. Similarly search the last occurance. 
// Time Complexity = O(logn) 
// Space Complexity = O(1)
//Executed the code in leetcode

class Solution {
    public int[] searchRange(int[] nums, int target) {

        if(nums == null || nums.length == 0) return new int[] {-1,-1};

        int [] result = new int [2];
        int first = 0, last = 0, mid1 = 0;
        int low = 0, high = nums.length -1;

    if(nums[0] > target || nums[nums.length - 1] < target) return new int[]{-1,-1};
    
        int left = BinarySLeft(nums, target, 0, high);
        if( left == -1) return new int[] {-1,-1};
        int right = BinarySRight(nums, target, left, high);
        return new int[] {left,right};

    }

    private int BinarySLeft (int [] nums, int target, int low, int high){
        while(low <= high) {

        int mid = low + (high - low)/2;
        if(nums[mid] == target){
            if ((mid == 0) || nums[mid] > nums[mid-1])
                return mid;
            else high = mid - 1;     
        }
        else if(target < nums[mid]){
            high = mid - 1;
        }
        else low = mid + 1;

        }
    return -1;
    }

        private int BinarySRight (int [] nums, int target, int low, int high){
            while(low <= high){
            int mid = low + (high - low)/2;
        if(nums[mid] == target){
            if ((mid == (nums.length - 1)) || nums[mid] < nums[mid+1])
                return mid;
            else low = mid + 1;
        
        }
        else if(target < nums[mid]){
            high = mid - 1;
        }
        else low = mid + 1;
    }
    return -1;
            }
        
}    
