/**
Find any peak element.
Time Complexity : 
Space Complexity : 
Algorithm : 
1. Apply binary search to find element
2. Once found mid, check if its neighbours are less than mid. If not then move to the side which has greater element. 
3. Cover corner cases by checking mid is on 0th position or last element in the array.
*/

class Solution {
    public int findPeakElement(int[] nums) {
        if(nums == null || nums.length == 0)
            return -1; 
        int low = 0;
        int high = nums.length - 1;
        while(low <= high){
            int mid = low + (high - low) / 2;
            if( (mid == 0 || nums[mid] > nums[mid - 1]) && (mid == nums.length - 1 || nums[mid] > nums[mid + 1])){
                return mid;
            }else if(mid > 0 && nums[mid] < nums[mid - 1]){
                high = mid - 1;                
            }else
                low = mid + 1;
        }
        return -1;
    }
}
